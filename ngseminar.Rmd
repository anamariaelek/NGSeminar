---
title: "NGSeminar: R - functions and fundamentals"
author: "Anamaria Elek"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
    df_print: default
---

# Introduction

Who is this for?  

People who are familiar with the basics of R and who want to understand and write better R code.

What will I learn?

* understand how basic things in R work under-the-hood,
* why some things are slow
* and how to make them faster.

# Setup

Install the packages (if necessary).

```{r warning=FALSE, message=FALSE}
packages <- c("lobstr","data.table","microbenchmark","parallel","foreach","doParallel")
for (pkg in packages) {
  if (!requireNamespace(pkg, quietly = TRUE))
    install.packages(pkg)
}
```

Load the packages.

```{r warning=FALSE, message=FALSE}
library(lobstr)
library(data.table)
library(microbenchmark)
library(parallel)
library(foreach)
library(doParallel)
```

# Variable binding

Create an integer vector `c(1,2,3)` and assign it to the variable called `v1`.

```{r}
v1 <- c(1,2,3)
require(lobstr)
obj_addr(v1)
```

The object is copied when modified

```{r}
v1[1] <- 0
obj_addr(v1)
```

This **copy-on-modify** behavior can slow down the code execution and use up the available memory. 

Why does this happen?

```
v1 -> c(1,2,3)
```

> The object (or value) doesn't have a name, it is actually the name that has a value.

Assigning the same object to different variables doesn't create any copies.

```{r}
v2 <- v1
obj_addr(v1)
obj_addr(v2)
```

You can see that the address is the same. It's only once this object is changed that it gets copied, as we've seen above.  

The elements of the lists are also pointers to the actual values. 

```{r}
l1 <- list(1,2,3)
l2 <- l1
l2[[1]] <- 0
ref(l1,l2)
```

Copies of lists are **shallow copies**.  

This affects the size of lists.

```{r}
x <- runif(1e6)
y <- list(x1=x,x2=x,x3=x)
obj_size(x)
obj_size(y)
ref(y)
```

Extension to data frames.

```{r}
d1 <- data.frame(x=c(1,2,3), y=c(4,5,6))
d1
```

Modifying rows vs columns.

```{r}
d2 <- d1
d2[,1] <- d2[,1]+3
ref(d1,d2)
d3 <- d1
d3[1,] <- d3[1,]+1
ref(d1,d3)
```

The similar is true for character vectors.

```{r}
ch <- "character"
obj_size(ch)
obj_size(rep(ch,100))
ref(rep(ch,2), character=TRUE)
```

Exceptions from general copy-on-modify behavior include environments and objects with single bindings, as well as objects of specific classes implemented in additional packages.

```{r}
dt <- data.table::setDT(d1)
dt[,x:=x+1]
ref(d1,dt)
```

***

Pause for thought: what do you think happened to the vector we created at the beginning `v1 <- c(1,2,3)` which is now without a name?

The answer: **garbage collector (GC)**!

***

# Functions

## Functional programming

Two types of programming (languages):
* **object-oriented programming** (OOP)
* **functional** 

In R we can do both, but at it's core, it is (closer to) a functional programming language

> Functional programming in R is much more important than object-oriented programming, because you typically solve complex problems by decomposing them into simple functions, not simple objects.  

## Writing a function

Why bother?

Code in one place, easier to read and update, less mistakes.

This is part of a **“do not repeat yourself” (DRY) principle**.

What makes a good function?  

It should do one thing only, and do it well.  

```{r}
addition <- function(x, y) x + y
```

A function has:

* name
* arguments  
* body of the function    
* environment  

```{r}
addition <- function(x, y) {
  z <- x + y
  return(z)
}
```

Calling a function

```{r}
addition(x=1, y=2)
addition(1, 2)
addition(y=2, x=2)
```

Default arguments

```{r}
increment <- function(x, y=1) {
  x + y
}
increment(x=2)
increment(x=2, y=2)
```

A special argument: `...`

```{r}
logodds <- function(x, y, ...) {
  log(x/y, ...)
}
logodds(2,3, base=10)
```

## Scoping

R uses **lexical scoping**. There are four main rules that define it.

### 1. Names defined inside a function mask names defined outside a function.

R first looks for a name defined inside a function.

```{r}
x <- 10
f1 <- function() {
  x <- 1
  return(x)
}
f1()
```

If a name is not defined inside a function, R looks one level up, i.e. in the environment from which the function is called (usually global environment). Finally, it looks in other loaded packages.

```{r}
f1 <- function() {
  x
}
f1()
```

### 2. Execution enviroment

Every time a function is called a new environment is created to host its execution. The variables created in this environment are not available outside of it, after the function is executed.

```{r}
f2 <- function() {
  fa <- 1
  return(fa)
}
f2()
exists("fa")
```

### 3. Functions versus variables

If a function and non-function object have the same name, R can still distinguishes the two.

```{r}
# function f3() defined in global environment
f3 <- function(x) x+1

f4 <- function(x) {
  # integer object f3 defined in function environment
  f3 <- 10
  
  # R looks for a function f3() and a non-function f3
  f3(f3)
}

f4()
```

### 4. Dynamic lookup

R looks for values when the function is run, not when the function is created.

```{r}
x <- 15
f4 <- function() x + 1
f4()
x <- 20
f4()
```

## Lazy evaluation

![](images/sloth.png){width=50%}

Lazy evaluation means that arguments are evaluated only if they are accessed by the function body.

```{r}
f5 <- function(x, y) x
f5(x=10, y=rubbish)
```

## Exiting a function

If a function cannot be completed, it  should return an error message.

```{r error=TRUE}
f6 <- function(x) {
  if (!is.numeric(x)) 
    stop("x is not numeric!")
  return(x)
}
f6("word")
```

The function can also output messages and warnings which don't interrupt the function execution.

```{r error=TRUE}
f7 <- function(x) {
  if (!is.numeric(x)) {
    warning("x is not numeric, returning random x")
    x <- runif(1)
  } else
    message("returnig input x")
  return(x)
}
f7(1)
f7("word")
```

# Control flow

Control flow is the order in which code is executed. 
Two main ways to control the flow of execution in R: choices and loops. 

## Choices
### `if`

Syntax

```
if (condition) true_action
if (condition) true_action else false_action
```

Example

```{r}
f7 <- function(x) {
  
  if (!is.numeric(x)) {
    
    warning("x is not numeric, returning random x")
    x <- runif(1)
  
  } else {
  
    message("returnig input x")
  
  }
  
  return(x)
}
```

The condition should always evaluate to a single `TRUE` or `FALSE`.

```{r error=TRUE}
val <- 10
if (val) print(val) else print("No input")

val <- "val"
if (val) print(val) else print("No input")
```

What would be returned in following examples?

```{r eval=FALSE}
x <- 1:10
if (length(x)) "not empty" else "empty"

x <- numeric()
if (length(x)) "not empty" else "empty"
```

If condition evaluates to a logical vector of length greater than 1, only the first argument will be used.

```{r warning=TRUE}
val <- c(10,20)
if (val) print(val) else print("No input")
```

In R 3.5.0 and greater you can choose to turn this warning into an error.

```{r eval=FALSE}
Sys.setenv("_R_CHECK_LENGTH_1_CONDITION_" = "true")
```

### `ifelse`

Vectored version of `if`.

```
ifelse(condition, yes, no)
```

Example

```{r}
x <- 1:5
ifelse(x < 3, "less", "greater or equal")
```

The result is a vector of the same length as the `condition`.  

The `yes` and `no` vectors should be of the same type,otherwise R will attempt to convert them.

```{r}
x <- 1:5
ifelse(x < 3, x, "greater or equal")
```

What do you expect the following example will return?

```{r eval=FALSE}
x <- length(numeric())
ifelse(x, 1:10, 11:20)
```

### `switch`

A compact equivalent to if statement.

An example of `if()`:

```{r}
x <- "a"
if (x == "a") {
  "option 1"
} else if (x == "b") {
  "option 2" 
} else if (x == "c") {
  "option 3"
} else {
  stop("Invalid `x` value")
}
```

With `switch()`:

```{r}
switch(x,
  a = "option 1",
  b = "option 2",
  c = "option 3",
  stop("Invalid `x` value")
)
```

`switch()` has a propagation property. How do you think this example would work?

```{r eval=FALSE}
switch(x,
  a = ,
  b = "option 1",
  c = "option 2",
  stop("Invalid `x` value")
)
```

The last option in `switch()` statement should always throw an error.

```{r}
switch("c", a = 1, b = 2)
```

## Loops

### `for`

`for` loops are used to iterate over items in a vector (or list).

```
for (item in vector) perform_action
```

Example:

```{r}
for (i in 1:3) {
  print(i)
}
```

Loops are overwriting the variables!

```{r}
i <- 20
for (i in 1:3) {
  print(i)
}
i
```

Terminating a for loop:

* `next` exits the current iteration
* `break` exits the entire `for` loop

```{r}
for (i in 1:10) {
  if (i < 3) 
    next

  print(i)
  
  if (i >= 5)
    break
}
```

Saving the output of the each loop iteration.

```{r eval=FALSE}
out <- list()
for (i in 1:1e5) {
  out[[i]] <- runif(1000)
}
```

Pre-allocate the output container of final size!

```{r eval=FALSE}
out <- vector("list", 1e5)
for (i in 1:1e5) {
  out[[i]] <- runif(1000)
}
```

Benchmark this!

### `while` and `repeat`

* `while(condition) action` performs action while condition is `TRUE`

```{r}
i <- 1
while (i < 5) {
  i <- i + 1
  print(i)
}
```

* `repeat(action)` repeats action until it encounters `break`

```{r}
i <- 1
repeat({
  i <- i + 1
  print(i)
  if (i == 5) break
})
```

Flexibility:

`repeat` > `while` > `for` 

# Functionals

A function that takes another function as an argument.

Specialized functionals that are better alternative for loops:

* `apply()` is specialized to work with two-dimensional and higher vectors, i.e. matrices and arrays
* `lapply()` and related `sapply()` can be used to iterate over one-dimensional vector elements

### `apply()`

`apply(X, MARGIN, FUN, ...)`

* `X`
* `MARGIN`
* `FUN`
* `...` 

Examples: 

```{r}
a2d <- matrix(1:20, nrow = 5)
a2d
apply(a2d, 1, mean)
apply(a2d, 1, function(x) x+1)
apply(a2d, 1:2, function(x) x+1)
a3d <- array(1:24, c(2, 3, 4))
a3d
apply(a3d, 1, mean)
apply(a3d, c(1,3), mean)
```

### `lapply()`, `sapply()` and `vapply()`

`lapply(X, FUN, ...)`

Example:

```{r}
v <- list(A=0:10, B=sample(1:100,10), C=runif(10))
lapply(X = v, FUN = mean)
```
 
`sapply(X, FUN, ..., simplify, USE.NAMES)`

```{r}
sapply(X = v, FUN = mean)
```

`vapply(X, FUN, ..., FUN.VALUE)` 

```{r}
fv <- vector(mode = "numeric", length = 1)
vapply(X = v, FUN = mean, FUN.VALUE = fv)

fv <- summary(v$A)
vapply(X = v, FUN = summary, FUN.VALUE = fv)
```

### `tapply()`

`tapply(X, INDEX, FUN, ...)`

```{r}
x <- runif(100)
y <- sample(LETTERS[1:3], 100, replace=TRUE)
tapply(x, y, mean)
```

### `mapply()`

```
mapply(FUN, ..., MoreArgs, SIMPLIFY, USE.NAMES)
```

```{r}
x <- 1:5
y <- 3:7
mapply(sum, x, y)
```

### `rapply()`

`rapply(object, f, classes, deflt, how)` 

```{r}
x <- list(A=runif(10), B=LETTERS[1:4], c=matrix(1:9,nrow=3))
x
rapply(x, mean, classes=c("integer","numeric"), how="replace")
rapply(x, mean, classes=c("integer","numeric"), how="list", deflt=NA)
rapply(x, mean, classes=c("integer","numeric"), how="unlist", deflt=NA)
```

# Paralellization

### `mclapply()`

```
mclapply(X, FUN, ..., mc.cores)
```

```{r}
require(parallel)
v <- replicate(n=4, expr=rnorm(1e3), simplify=FALSE)
mclapply(v, mean, mc.cores=4)
```

Forking only works for UNIX-like systems. so you can't use `mclapply` with `mc.cores` > 1 on Windows.

Inspect results!

```{r}
res <- mclapply(1:4, function(i) {
  if (i == 3L) 
    stop("error in this process!") 
  else 
    return("success!")
}, mc.cores = 4)

lapply(res,class)
```

### `parLapply()`

```
parLapply(cl, X, fun, ...)
```
Have too register cluster explicitly (sockets), but it works on Windows.

```{r}
cl <- makeCluster(4)
clusterExport(cl, "v")
parLapply(cl=cl, X=v, fun=mean)
stopCluster(cl)
```

### `foreach %dopar%`

```{r}
require(foreach)
require(doParallel)
```

Register cluster explicitly (sockets).

```{r}
cl <- makeCluster(4)
registerDoParallel(cl)
foreach(i=v) %dopar% mean(i)
stopCluster(cl)
```

Or register cluster implicitly and only specifying the number of cores (forking).

```{r}
registerDoParallel(cores=2)
foreach(i=v) %dopar% mean(i)
```

### To parallelize or not?

Example: calculate a confidence interval of a statistic by bootstrapping.

```{r}
set.seed(123)
x <- rnorm(1000)

boot_seq <- function(x, n=1000) {
  sapply(1:n, function(x) median(sample(x, replace=TRUE)))
}
boot_par <- function(x, n=1000, ncores=4) {
  cl <- makeCluster(ncores)
  clusterExport(cl, varlist=c("x","n"), envir=environment())
  parSapply(cl, 1:n, function(x) median(sample(x, replace=TRUE)))
  stopCluster(cl)
}

microbenchmark(
  ci_seq = quantile(boot_seq(x), c(0.025, 0.975)),
  ci_par = quantile(boot_par(x), c(0.025, 0.975)), 
  times = 1L
)

```

If more time is spent on distributing resources and tasks, and merging outputs afterwards, the parallelization could be slower than serial computation!

One clear advantage of serial computations is that it allows you to better keep track on memory - pay attention to this when parallelizig!


# How to make my code faster?

* use specialized functions for specific tasks

`rowSums()`, `colSums()`, `rowMeans()`, and `colMeans()` are faster than equivalent `apply()` calls

```{r}
m <- matrix(runif(1e6),nrow=1000)
microbenchmark(
  rowSums(m),
  apply(m, 1, sum)
)
```

`which.min()` and `which.max()` functions can be orders of magnitude faster than `which(x == min(x))`

```{r}
x <- runif(1e5)
microbenchmark( 
  which(x == min(x)),
  which.min(x) 
)
```

* `unlist(x, use.names=FALSE)` is much faster than `unlist(x)` 

```{r}
x <- as.list(runif(10e3))
names(x) <- sample(LETTERS,length(x),replace=TRUE)
microbenchmark(
  unlist(x),
  unlist(x, use.names=FALSE)
)
```

* `readr::read_csv()` or `data.table::fread()` are considerably faster than `read.csv()`, and for many statistical functions there is a faster implementation in `Rfast` package - learn about different packages!

* use matrix algebra to solve your problems whenever possible

# Reading materials

Most of the material covered in this webinar was based on the following books.  

[![Advanced R](images/advanced_r.png){width=30%}](https://adv-r.hadley.nz/) 
[![Efficient R programming](images/efficient_r_programming.png){width=30%}](https://csgillespie.github.io/efficientR/) 
[![R for Data Science](images/r_for_data_science.png){width=30%}](https://r4ds.had.co.nz/)  

# Session info

```{r echo=FALSE}
sessionInfo()
```

